## This is a boilerplate file so that we can quickly get widgets up and running
## To easily delete all the instructional comments do:
##     ctrl+f, alt+r    (search by regex)
##     in search widget that appears: " *##.*\n"
##     alt+enter, delete
import os

## Kivy imports are placed after standard library imports
import kivy

kivy.require("1.2.0")
from kivy.app import App

## Styling can be defined using the Builder class, either by importing an
## external kv file or via the load_string function. Here we have used
## load_string because there is little required for this example, however
## typically we will require much more styling and as such should split it
## into it's own .kv file
from kivy.lang import Builder
from kivy.properties import NumericProperty
from kivy.uix.boxlayout import BoxLayout

# kv_filename = "example.kv"
# path_to_kv = os.path.join(os.path.dirname(__file__), kv_filename)
# Builder.load_file(path_to_kv)
Builder.load_string(
    """
<Example>:
    size_hint: (1,1)
    Label:
        text: "Hello World"
    Button:
        text: str(root.number)
        on_press: root.set_state(root.number + 1)
"""
)


class Example(BoxLayout):
    ## Any state variables should be mirrored in any possible parent app
    ## instance. For example number is mirrored by global_number below. It
    ## should also be mirrored in TopsideApp.py
    number = NumericProperty(1)

    ## Here we bind the terminal's local state to the App's global state.
    ## By doing this we know we can grab the global state just by accessing
    ## the class property number. We can also listen to state changes within
    ## the class using the on_number method generated by kivy.
    def on_parent(self, widget, parent):
        ## By using App.get_running_app() we can set the state regardless of
        ## whether the App instance originates in this file or TopsideApp.py
        if parent:
            App.get_running_app().bind(global_number=self.on_state_change)

    def on_state_change(self, instance, value):
        self.number = value

    ## As self.number is bound to global_number we can simply just inspect the
    ## local value. (We don't necessarily need a getter function)
    def get_state(self):
        return self.number

    ## We can set the global app value directly and this will be mirrored by
    ## our local number variable due to the prior binding. (We don't
    ## necessarily need a setter function)
    def set_state(self, val):
        App.get_running_app().global_number = val


## This will run if this widget is invoked directly by the user,
## i.e. in the terminal run: python boilerplate.py
## This gives us the advantage of being able to silo our widget development
## before integrating it into seawolf proper.
if __name__ == "__main__":

    class WidgetApp(App):
        global_number = NumericProperty(1)

        def build(self):
            return Example()

    WidgetApp().run()
